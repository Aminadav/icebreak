const fs = require('fs');const path = require('path');const sharp = require('sharp');const crypto = require('crypto');/** * Image utilities for handling user images */class ImageUtils {    /**   * Generate hash for image file   * @param {Buffer} imageBuffer - Image buffer   * @returns {string} MD5 hash   */  static generateImageHash(imageBuffer) {    return crypto.createHash('md5').update(imageBuffer).digest('hex');  }  /**   * Save image to uploads directory with hash filename   * @param {Buffer} imageBuffer - Image buffer   * @param {string} extension - File extension (e.g., 'jpg', 'png')   * @returns {Promise<{hash: string, filePath: string}>}   */  static async saveImage(imageBuffer, extension = 'jpg') {    try {      const uploadsDir = path.join(__dirname, '..', 'uploads');      await fs.promises.mkdir(uploadsDir, { recursive: true });            const hash = this.generateImageHash(imageBuffer);      const fileName = `${hash}.${extension}`;      const filePath = path.join(uploadsDir, fileName);            // Check if file already exists (deduplication)      if (await this.imageExists(hash, extension)) {        console.log(`‚úÖ Image already exists: ${fileName}`);        return { hash, filePath };      }            await fs.promises.writeFile(filePath, imageBuffer);            console.log(`‚úÖ Image saved: ${fileName}`);      return { hash, filePath };    } catch (error) {      console.error('‚ùå Error saving image:', error);      throw error;    }  }  /**   * Get image by hash   * @param {string} hash - Image hash   * @param {string} extension - File extension   * @returns {string} File path   */  static getImagePath(hash, extension = 'jpg') {    return path.join(__dirname, '..', 'uploads', `${hash}.${extension}`);  }  /**   * Check if image exists   * @param {string} hash - Image hash   * @param {string} extension - File extension   * @returns {Promise<boolean>}   */  static async imageExists(hash, extension = 'jpg') {    try {      const filePath = this.getImagePath(hash, extension);      await fs.promises.access(filePath, fs.constants.F_OK);      return true;    } catch {      return false;    }  }  /**   * Create thumbnail of existing image and save it   * @param {string} originalHash - Hash of original image   * @returns {Promise<{hash: string, filePath: string}>}   */  static async createThumbnailImage(originalHash) {    try {      const originalPath = this.getImagePath(originalHash, 'jpg');            // Read original image and create thumbnail      const thumbnailBuffer = await sharp(originalPath)        .resize(256, 256, {          fit: 'cover',          position: 'center'        })        .jpeg({ quality: 90 })        .toBuffer();            // Save thumbnail with its own hash      return await this.saveImage(thumbnailBuffer, 'jpg');    } catch (error) {      console.error('‚ùå Error creating thumbnail image:', error);      throw error;    }  }  /**   * Get web-accessible URL for image   * @param {string} hash - Image hash   * @param {string} extension - File extension   * @returns {string} Web URL   */  static getImageUrl(hash, extension = 'jpg') {    return `/uploads/${hash}.${extension}`;  }  /**   * Convert file path to hash (for existing uploaded files)   * @param {string} filePath - Path to image file   * @returns {Promise<string>} Hash of the file   */  static async getFileHash(filePath) {    try {      const buffer = await fs.promises.readFile(filePath);      return this.generateImageHash(buffer);    } catch (error) {      console.error('‚ùå Error getting file hash:', error);      throw error;    }  }  /**   * Clean up old images not referenced in database   * @param {Array<string>} activeHashes - Array of hashes that should be kept   * @returns {Promise<number>} Number of images cleaned up   */  static async cleanupUnusedImages(activeHashes = []) {    try {      const uploadsDir = path.join(__dirname, '..', 'uploads');      const files = await fs.promises.readdir(uploadsDir);            let cleanedCount = 0;            for (const file of files) {        const filePath = path.join(uploadsDir, file);        const stat = await fs.promises.stat(filePath);                if (stat.isFile() && file.match(/^[a-f0-9]{32}\.(jpg|png|jpeg)$/i)) {          const hash = file.split('.')[0];                    if (!activeHashes.includes(hash)) {            await fs.promises.unlink(filePath);            console.log(`üóëÔ∏è Cleaned up unused image: ${file}`);            cleanedCount++;          }        }      }            console.log(`‚úÖ Cleaned up ${cleanedCount} unused images`);      return cleanedCount;    } catch (error) {      console.error('‚ùå Error cleaning up unused images:', error);      return 0;    }  }}module.exports = ImageUtils;
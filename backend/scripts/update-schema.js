const pool = require('../config/database');
const fs = require('fs');
const path = require('path');
require('dotenv').config({path: __dirname + '/../.env'});

async function updateSchema() {
  const client = await pool.connect();
  
  try {
    console.log('ðŸ” Extracting database schema...');
    
    // Get all tables with their columns, types, and constraints
    const schemaQuery = `
      SELECT 
        t.table_name,
        c.column_name,
        c.data_type,
        c.character_maximum_length,
        c.is_nullable,
        c.column_default,
        c.is_generated,
        c.generation_expression,
        tc.constraint_type,
        kcu.constraint_name,
        ccu.table_name AS foreign_table_name,
        ccu.column_name AS foreign_column_name
      FROM 
        information_schema.tables t
        LEFT JOIN information_schema.columns c ON t.table_name = c.table_name
        LEFT JOIN information_schema.key_column_usage kcu ON c.table_name = kcu.table_name AND c.column_name = kcu.column_name
        LEFT JOIN information_schema.table_constraints tc ON kcu.constraint_name = tc.constraint_name
        LEFT JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name
      WHERE 
        t.table_schema = 'public'
        AND t.table_type = 'BASE TABLE'
        AND t.table_name != 'schema_migrations'
      ORDER BY 
        t.table_name, c.ordinal_position;
    `;
    
    const result = await client.query(schemaQuery);
    
    if (result.rows.length === 0) {
      console.log('ðŸ“‹ No tables found in the database.');
      return;
    }
    
    // Group results by table
    const tables = {};
    const constraints = {};
    
    result.rows.forEach(row => {
      if (!tables[row.table_name]) {
        tables[row.table_name] = [];
        constraints[row.table_name] = [];
      }
      
      // Add column info if not already added
      const existingColumn = tables[row.table_name].find(col => col.column_name === row.column_name);
      if (!existingColumn && row.column_name) {
        let columnDef = `  "${row.column_name}" ${row.data_type.toUpperCase()}`;
        
        // Add length for varchar
        if (row.character_maximum_length) {
          columnDef += `(${row.character_maximum_length})`;
        }
        
        // Handle generated columns
        if (row.is_generated === 'ALWAYS') {
          columnDef += ` GENERATED ALWAYS AS (${row.generation_expression}) STORED`;
        } else {
          // Add NOT NULL constraint for non-generated columns
          if (row.is_nullable === 'NO') {
            columnDef += ' NOT NULL';
          }
          
          // Add default value for non-generated columns
          if (row.column_default) {
            columnDef += ` DEFAULT ${row.column_default}`;
          }
        }
        
        tables[row.table_name].push({
          column_name: row.column_name,
          definition: columnDef
        });
      }
      
      // Add constraints
      if (row.constraint_type && row.constraint_name) {
        const existingConstraint = constraints[row.table_name].find(c => c.constraint_name === row.constraint_name);
        if (!existingConstraint) {
          let constraintDef = '';
          
          if (row.constraint_type === 'PRIMARY KEY') {
            constraintDef = `  CONSTRAINT "${row.constraint_name}" PRIMARY KEY ("${row.column_name}")`;
          } else if (row.constraint_type === 'FOREIGN KEY' && row.foreign_table_name) {
            constraintDef = `  CONSTRAINT "${row.constraint_name}" FOREIGN KEY ("${row.column_name}") REFERENCES "${row.foreign_table_name}"("${row.foreign_column_name}")`;
          } else if (row.constraint_type === 'UNIQUE') {
            constraintDef = `  CONSTRAINT "${row.constraint_name}" UNIQUE ("${row.column_name}")`;
          }
          
          if (constraintDef) {
            constraints[row.table_name].push({
              constraint_name: row.constraint_name,
              definition: constraintDef
            });
          }
        }
      }
    });
    
    // Generate SQL schema
    let schemaSQL = `-- Database Schema Generated on ${new Date().toISOString()}\n`;
    schemaSQL += `-- This file is auto-generated by update-schema.js\n`;
    schemaSQL += `-- DO NOT EDIT MANUALLY - Run 'node scripts/update-schema.js' to update\n\n`;
    
    // Add tables
    Object.keys(tables).sort().forEach(tableName => {
      schemaSQL += `-- Table: ${tableName}\n`;
      schemaSQL += `CREATE TABLE IF NOT EXISTS "${tableName}" (\n`;
      
      // Add columns
      const columnDefs = tables[tableName].map(col => col.definition);
      const constraintDefs = constraints[tableName].map(con => con.definition);
      
      const allDefs = [...columnDefs, ...constraintDefs];
      schemaSQL += allDefs.join(',\n');
      schemaSQL += `\n);\n\n`;
    });
    
    // Get and add indexes
    console.log('ðŸ” Extracting database indexes...');
    const indexQuery = `
      SELECT 
        schemaname,
        tablename,
        indexname,
        indexdef
      FROM 
        pg_indexes 
      WHERE 
        schemaname = 'public'
        AND tablename != 'schema_migrations'
        AND indexname NOT LIKE '%_pkey'
      ORDER BY 
        tablename, indexname;
    `;
    
    const indexResult = await client.query(indexQuery);
    
    if (indexResult.rows.length > 0) {
      schemaSQL += `-- Indexes\n`;
      indexResult.rows.forEach(row => {
        schemaSQL += `${row.indexdef};\n`;
      });
      schemaSQL += `\n`;
    }

    // Get and add triggers
    console.log('ðŸ” Extracting triggers...');
    const triggerQuery = `
      SELECT 
        trigger_name,
        event_manipulation,
        event_object_table,
        action_statement,
        action_timing
      FROM 
        information_schema.triggers
      WHERE 
        trigger_schema = 'public'
      ORDER BY 
        event_object_table, trigger_name;
    `;
    
    const triggerResult = await client.query(triggerQuery);
    
    if (triggerResult.rows.length > 0) {
      schemaSQL += `-- Triggers\n`;
      triggerResult.rows.forEach(row => {
        schemaSQL += `-- Trigger: ${row.trigger_name} on ${row.event_object_table}\n`;
        schemaSQL += `CREATE TRIGGER ${row.trigger_name}\n`;
        schemaSQL += `  ${row.action_timing} ${row.event_manipulation}\n`;
        schemaSQL += `  ON ${row.event_object_table}\n`;
        schemaSQL += `  ${row.action_statement};\n\n`;
      });
    }

    // Get and add functions
    console.log('ðŸ” Extracting functions...');
    const functionQuery = `
      SELECT 
        routine_name,
        routine_definition,
        data_type,
        routine_type
      FROM 
        information_schema.routines
      WHERE 
        routine_schema = 'public'
        AND routine_type = 'FUNCTION'
      ORDER BY 
        routine_name;
    `;
    
    const functionResult = await client.query(functionQuery);
    
    if (functionResult.rows.length > 0) {
      schemaSQL += `-- Functions\n`;
      functionResult.rows.forEach(row => {
        if (row.routine_definition) {
          schemaSQL += `-- Function: ${row.routine_name}\n`;
          schemaSQL += `${row.routine_definition}\n\n`;
        }
      });
    }
    
    // Write to schema.sql file
    const schemaPath = path.join(__dirname, 'schema.sql');
    fs.writeFileSync(schemaPath, schemaSQL);
    
    console.log(`âœ… Schema successfully exported to: ${schemaPath}`);
    console.log(`ðŸ“Š Exported ${Object.keys(tables).length} tables, ${indexResult.rows.length} indexes, ${triggerResult.rows.length} triggers, and ${functionResult.rows.length} functions`);
    
  } catch (error) {
    console.error('âŒ Error updating schema:', error.message);
    process.exit(1);
  } finally {
    client.release();
    await pool.end();
  }
}

// Run the script
if (require.main === module) {
  console.log('ðŸš€ Starting schema update...');
  updateSchema()
    .then(() => {
      console.log('ðŸŽ‰ Schema update completed successfully!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('ðŸ’¥ Schema update failed:', error);
      process.exit(1);
    });
}

module.exports = updateSchema;

const pool = require('../config/database');
const fs = require('fs');
const path = require('path');
require('dotenv').config({path: __dirname + '/../.env'});

async function updateSchema() {
  const client = await pool.connect();
  
  try {
    console.log('ðŸ” Extracting database schema...');
    
    // Get all tables with their columns, types, and constraints
    const schemaQuery = `
      SELECT 
        t.table_name,
        c.column_name,
        c.data_type,
        c.character_maximum_length,
        c.is_nullable,
        c.column_default,
        tc.constraint_type,
        kcu.constraint_name,
        ccu.table_name AS foreign_table_name,
        ccu.column_name AS foreign_column_name
      FROM 
        information_schema.tables t
        LEFT JOIN information_schema.columns c ON t.table_name = c.table_name
        LEFT JOIN information_schema.key_column_usage kcu ON c.table_name = kcu.table_name AND c.column_name = kcu.column_name
        LEFT JOIN information_schema.table_constraints tc ON kcu.constraint_name = tc.constraint_name
        LEFT JOIN information_schema.constraint_column_usage ccu ON tc.constraint_name = ccu.constraint_name
      WHERE 
        t.table_schema = 'public'
        AND t.table_type = 'BASE TABLE'
        AND t.table_name != 'schema_migrations'
      ORDER BY 
        t.table_name, c.ordinal_position;
    `;
    
    const result = await client.query(schemaQuery);
    
    if (result.rows.length === 0) {
      console.log('ðŸ“‹ No tables found in the database.');
      return;
    }
    
    // Group results by table
    const tables = {};
    const constraints = {};
    
    result.rows.forEach(row => {
      if (!tables[row.table_name]) {
        tables[row.table_name] = [];
        constraints[row.table_name] = [];
      }
      
      // Add column info if not already added
      const existingColumn = tables[row.table_name].find(col => col.column_name === row.column_name);
      if (!existingColumn && row.column_name) {
        let columnDef = `  "${row.column_name}" ${row.data_type.toUpperCase()}`;
        
        // Add length for varchar
        if (row.character_maximum_length) {
          columnDef += `(${row.character_maximum_length})`;
        }
        
        // Add NOT NULL constraint
        if (row.is_nullable === 'NO') {
          columnDef += ' NOT NULL';
        }
        
        // Add default value
        if (row.column_default) {
          columnDef += ` DEFAULT ${row.column_default}`;
        }
        
        tables[row.table_name].push({
          column_name: row.column_name,
          definition: columnDef
        });
      }
      
      // Add constraints
      if (row.constraint_type && row.constraint_name) {
        const existingConstraint = constraints[row.table_name].find(c => c.constraint_name === row.constraint_name);
        if (!existingConstraint) {
          let constraintDef = '';
          
          if (row.constraint_type === 'PRIMARY KEY') {
            constraintDef = `  CONSTRAINT "${row.constraint_name}" PRIMARY KEY ("${row.column_name}")`;
          } else if (row.constraint_type === 'FOREIGN KEY' && row.foreign_table_name) {
            constraintDef = `  CONSTRAINT "${row.constraint_name}" FOREIGN KEY ("${row.column_name}") REFERENCES "${row.foreign_table_name}"("${row.foreign_column_name}")`;
          } else if (row.constraint_type === 'UNIQUE') {
            constraintDef = `  CONSTRAINT "${row.constraint_name}" UNIQUE ("${row.column_name}")`;
          }
          
          if (constraintDef) {
            constraints[row.table_name].push({
              constraint_name: row.constraint_name,
              definition: constraintDef
            });
          }
        }
      }
    });
    
    // Generate SQL schema
    let schemaSQL = `-- Database Schema Generated on ${new Date().toISOString()}\n`;
    schemaSQL += `-- This file is auto-generated by update-schema.js\n`;
    schemaSQL += `-- DO NOT EDIT MANUALLY - Run 'node scripts/update-schema.js' to update\n\n`;
    
    // Add tables
    Object.keys(tables).sort().forEach(tableName => {
      schemaSQL += `-- Table: ${tableName}\n`;
      schemaSQL += `CREATE TABLE IF NOT EXISTS "${tableName}" (\n`;
      
      // Add columns
      const columnDefs = tables[tableName].map(col => col.definition);
      const constraintDefs = constraints[tableName].map(con => con.definition);
      
      const allDefs = [...columnDefs, ...constraintDefs];
      schemaSQL += allDefs.join(',\n');
      schemaSQL += `\n);\n\n`;
    });
    
    // Get and add indexes
    console.log('ðŸ” Extracting database indexes...');
    const indexQuery = `
      SELECT 
        schemaname,
        tablename,
        indexname,
        indexdef
      FROM 
        pg_indexes 
      WHERE 
        schemaname = 'public'
        AND tablename != 'schema_migrations'
        AND indexname NOT LIKE '%_pkey'
      ORDER BY 
        tablename, indexname;
    `;
    
    const indexResult = await client.query(indexQuery);
    
    if (indexResult.rows.length > 0) {
      schemaSQL += `-- Indexes\n`;
      indexResult.rows.forEach(row => {
        schemaSQL += `${row.indexdef};\n`;
      });
      schemaSQL += `\n`;
    }
    
    // Write to schema.sql file
    const schemaPath = path.join(__dirname, 'schema.sql');
    fs.writeFileSync(schemaPath, schemaSQL);
    
    console.log(`âœ… Schema successfully exported to: ${schemaPath}`);
    console.log(`ðŸ“Š Exported ${Object.keys(tables).length} tables and ${indexResult.rows.length} indexes`);
    
  } catch (error) {
    console.error('âŒ Error updating schema:', error.message);
    process.exit(1);
  } finally {
    client.release();
    await pool.end();
  }
}

// Run the script
if (require.main === module) {
  console.log('ðŸš€ Starting schema update...');
  updateSchema()
    .then(() => {
      console.log('ðŸŽ‰ Schema update completed successfully!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('ðŸ’¥ Schema update failed:', error);
      process.exit(1);
    });
}

module.exports = updateSchema;
